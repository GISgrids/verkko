import tempfile
import os
import re
import glob
import time
import math

SCRIPT_PATH=config['SCRIPT_PATH']
ROOT_PATH=config['ROOT_PATH']
HIFI_READS=glob.glob(os.path.expandvars(config['HIFI_READS']))
print("HiFi reads", HIFI_READS)
ONT_READS=glob.glob(os.path.expandvars(config['ONT_READS']))
print("ONT reads", ONT_READS)

localrules: all

rule all:
    input:
        'unitig-popped-unitig-normal-connected-tip.gfa'

rule build_graph:
    input:
        HIFI_READS
    output:
        gfa='hifi-resolved.gfa',
        paths='paths.gaf'
    threads: 8
    log:
        'graph_building.log'
    params:
        input_str=' '.join(expand('-i {r}', r=HIFI_READS)),
        baseK=config['MIN_KMER'],
        w=100,
        maxK=15000
    shell:
        '''
        MBG {params.input_str} -t {threads} -o {output.gfa} -k {params.baseK} -w {params.w} -a 1 -u 2 --error-masking=collapse-msat --output-sequence-paths {output.paths} -r {params.maxK} &> {log}
        '''

rule process_graph:
    input:
        gfa='hifi-resolved.gfa',
        paths='paths.gaf'
    output:
        processed_gfa='unitig-unrolled-hifi-resolved.gfa'
    shell:
        '''
        {SCRIPT_PATH}/insert_aln_gaps.py {input.gfa} 2 50 gaps-hifi-1.gaf gapone < {input.paths} > gapped-once-hifi-resolved.gfa
        {SCRIPT_PATH}/insert_aln_gaps.py gapped-once-hifi-resolved.gfa 2 300 gaps-hifi-2.gaf gaptwo < paths.gaf > gapped-twice-hifi-resolved.gfa
        {SCRIPT_PATH}/insert_aln_gaps.py gapped-twice-hifi-resolved.gfa 1 5 gaps-hifi-3.gaf gapthree < paths.gaf > gapped-hifi-resolved.gfa
        cut -f 6 < paths.gaf | {SCRIPT_PATH}/unroll_tip_loops.py gapped-hifi-resolved.gfa 5 > unrolled-hifi-resolved.gfa
        {SCRIPT_PATH}/get_unroll_mapping.py gapped-hifi-resolved.gfa unrolled-hifi-resolved.gfa > unroll_mapping_1.txt
        {SCRIPT_PATH}/unitigify.py "utig1-" unitig-mapping-1.txt < unrolled-hifi-resolved.gfa > {output.processed_gfa}
        '''

rule align_ont:
    input: reads=lambda wildcards: ONT_READS[int(wildcards.i)],
           graph='unitig-unrolled-hifi-resolved.gfa'
    output: 'ont_align/read_file{i}.gaf'
    threads: 32
    log: 'ont_align/read_file{i}.log'
    shell:
        '''
        GraphAligner -t {threads} -g {input.graph} -f {input.reads} -a {output} --seeds-mxm-length 30 --seeds-mem-count 1000 -b 15 --multimap-score-fraction 0.99 --precise-clipping 0.85 --min-alignment-score 5000 --hpc-collapse-reads --discard-cigar --clip-ambiguous-ends 100 --overlap-incompatible-cutoff 0.15 --max-trace-count 5 &> {log}
        '''

rule aggregate:
    input: expand('ont_align/read_file{i}.gaf', i=range(0, len(ONT_READS)))
    output: 'alns-ont.gaf'
    shell: 'cat {input} > alns-ont.gaf'

rule process_ont_paths:
#unitig-unrolled-hifi-resolved.gfa alns-ont.gaf unitig-unrolled-ont-resolved.gfa 5 20 10 5
    input: graph='unitig-unrolled-hifi-resolved.gfa',
           ont_paths='alns-ont.gaf'
    output: graph='unitig-unrolled-ont-resolved.gfa',
            #TODO pass as parameter?
            ont_gap_align='gaps-ont.gaf'
    log: 'process_ont_paths.log'
    params:
        min_allowed_cov=5,
        resolve_steps='20 10 5'
    shell:
        '''
        {ROOT_PATH}/process_ont_paths.sh {input.graph} {input.ont_paths} {output.graph} {params.min_allowed_cov} {params.resolve_steps} &> {log}
        '''

rule postprocess:
    input: 'unitig-unrolled-ont-resolved.gfa'
    output: 'unitig-popped-unitig-normal-connected-tip.gfa'
    log: 'postprocess.log'
    shell:
        '''
        {ROOT_PATH}/postprocess.sh {input} {output} &> {log}
        '''

rule create_layout:
    input: graph='unitig-popped-unitig-normal-connected-tip.gfa'
    output:
        'layout.txt',
        'gaps.txt'
    threads: 1
    shell:
        '''
        cat *mapping* > combined-nodemap.txt
        cat *.gfa | grep -P '^L' > combined-edges.gfa
        cat gaps-*.gaf paths.gaf > combined-alignments.gaf
        grep -P '^S' *.gfa | grep -v '\\*' | awk '{print $2 "\\t" length($3);}' > nodelens.txt
        grep -P '^S' {input.graph} | awk '{print $2 "\\t" ">" $2;}' > consensus_paths.txt
        {SCRIPT_PATH}/get_layout_from_mbg.py combined-nodemap.txt combined-edges.gfa combined-alignments.gaf consensus_paths.txt nodelens.txt > layout.txt 2> unitig_to_mbg_list.txt
        {SCRIPT_PATH}/check_layout_gaps.py < layout.txt > gaps.txt
        '''
